\documentclass[12pt]{article}
\usepackage[brazil]{babel}
\usepackage[a4paper, total={6.5in, 9.5in}]{geometry}
\usepackage[utf8]{inputenc}

\usepackage{authblk}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{amssymb}
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{verbatimbox}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codered}{rgb}{0.8,0,0}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{inconsolata}
\lstset{
    language=python,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codered},
    basicstyle=\ttfamily\small,
    numberstyle=\footnotesize,
    numbers=left,
    backgroundcolor=\color{white},
    frame=single,
    tabsize=2,
    rulecolor=\color{white},
    title=\lstname,
    escapeinside={\%*}{*)},
    breaklines=true,
    breakatwhitespace=true,
    framextopmargin=2pt,
    framexbottommargin=2pt,
    inputencoding=utf8,
    extendedchars=true,
    showstringspaces=false,
    literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1 {Ó}{{\'O}}1 {Ã}{{\~A}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ç}{{\.c}}1 {ê}{{\^e}}1 {ú}{{\'u}}1,
}

% \pagecolor[rgb]{0.1,0.1,0.1} %black
% \color[rgb]{0.75,0.75,0.75} %grey

\title{\textbf{Segurança Computacional\\ \Large{Advanced Encryption Standard}}}
\author{Pedro Henrique de Brito Agnes, 18/0026305
\\ Pedro Pessoa Ramos, 18/0026488
}
\affil{Dep. Ciência da Computação - Universidade de Brasília (UnB) \vspace{-2ex}}
\date{}

\begin{document}
\maketitle

\section{Geração e Verificação de Assinatura Digital}

\subsection{Implementação}
Foi desenvolvido um algoritmo em python na versão 3.8 ou acima que recebe um arquivo e gera a assinatura digital para ele ou verifica a assinatura. Para executar passando o documento \texttt{msg.txt}, pode-se usar o comando abaixo:

\begin{lstlisting}
python src/signature.py sample/msg.txt
\end{lstlisting}

Pode ser passado o argumento \texttt{-h} para o programa para a listagem de opções disponíveis conforme mostrado abaixo:

\begin{itemize}
    \item \textbf{-o} - Onde será feito o output. Obrigatório
    \item \textbf{-k} - Arquivo com a chave pública ou privada, a depender da operação. Obrigatório na decifração.
    \item \textbf{-d} - Argumento que indica que o programa vai descriptografar. Deve ser passado no final do comando sem parâmetros adicionais.
\end{itemize}

Por exemplo, para cifrar o arquivo \texttt{sample/msg.txt} com a chave pública \texttt{keys/key\_sample.pub} e armazenar o criptograma no arquivo \texttt{sample/cifra.txt}, pode ser usado o comando abaixo:

\begin{lstlisting}
python src/signature.py sample/msg.txt -k keys/key_sample.pub -o sample/cifra.txt
\end{lstlisting}

Da mesma forma, para decifrá-lo e armazenar o resultado em um arquivo \texttt{sample/out.txt}, pode-se usar o comando abaixo que utiliza a chave privada:

\begin{lstlisting}
python src/signature.py sample/cifra.txt -k keys/key_sample -o sample/out.txt -d
\end{lstlisting}

\subsection{RSA}
\subsubsection{Geração de Chaves}

Inicialmente são gerados 2 números primos aleatórios \texttt{p} e \texttt{q} de 1024 bits cada. Para obter estes números, foi inicialmente gerado um número qualquer do tamanho especificado, em seguida, sua primalidade foi testada para cada um dos primos até 1000, que foram dispostos em um array após serem computados uma única vez pelo crivo de Erastótenes. Em seguida, é realizado o teste de primalidade probabilístico de Miller Rabin, executado 20 vezes. Se ambos os testes passarem, o número é considerado primo e selecionado. Caso contrário, um novo número aleatório é gerado para realizar o teste novamente. Os códigos relacionados à geração e verificação dos primos estão localizados na pasta \texttt{src/util/primes.py}, incluindo a implementação do algoritmo de Miller Rabin.

Com \texttt{p} e \texttt{q} definidos, a chave pública é obtida usando 2 valores, o \texttt{n} e o \texttt{e}. O número \texttt{n} é o resultado da multiplicação de \texttt{p} e \texttt{q}, logo sendo de 2048 bits e já o \texttt{e} será um primo bem menor que \texttt{p} e \texttt{q}. Já a chave privada é obtida pela função totiente de Euler em \texttt{n}, onde temos a multiplicação de 2 números primos, logo, podendo ser calculada pela fórmula abaixo:

\[
    \phi(n) = (p-1) \times (q-1)
\]

Com o resultado da função acima, é calculado o seu inverso multiplicativo com \texttt{e} para assim obter o valor de \texttt{d} que é o único valor necessário para a chave privada. Para fins de performance, também são adicionados os valores de \texttt{p} e \texttt{q} na chave privada. Após a geração, as chaves são guardadas na pasta \texttt{keys} com a formatação base64, sendo a pública com a extensão \texttt{.pub}.

\subsubsection{}


\end{document}
